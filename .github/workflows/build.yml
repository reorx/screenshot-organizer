name: Build and Package App

on:
  push:
    branches: [ master, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Cache Swift Package Manager
      uses: actions/cache@v4
      with:
        path: |
          .build
          *.xcodeproj/project.xcworkspace/xcshareddata/swiftpm
        key: ${{ runner.os }}-spm-${{ hashFiles('Package.swift', 'Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-
    
    - name: Import Developer ID Certificate
      if: ${{ secrets.DEVELOPER_ID_APPLICATION_CERT_P12_BASE64 != '' && secrets.DEVELOPER_ID_APPLICATION_CERT_P12_BASE64 != null }}
      run: |
        # Create certificates directory
        mkdir -p ~/certs
        
        # Decode and import Developer ID Application certificate
        echo "${{ secrets.DEVELOPER_ID_APPLICATION_CERT_P12_BASE64 }}" | base64 --decode > ~/certs/developer_id_application.p12
        
        # Create temporary keychain
        KEYCHAIN_NAME="build-$(uuidgen)"
        KEYCHAIN_PATH="$HOME/Library/Keychains/$KEYCHAIN_NAME.keychain-db"
        echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
        echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
        
        # Create and unlock keychain
        security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" "$KEYCHAIN_PATH"
        
        # Import certificate
        security import ~/certs/developer_id_application.p12 \
                 -P "${{ secrets.DEVELOPER_ID_APPLICATION_CERT_PASSWORD }}" \
                 -k "$KEYCHAIN_PATH" \
                 -T /usr/bin/codesign \
                 -T /usr/bin/security
        
        # Set keychain search list
        security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain
        
        # Allow codesign to access the key
        security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" "$KEYCHAIN_PATH"
        
        # Set code signing identity
        echo "CODE_SIGN_IDENTITY=Developer ID Application" >> $GITHUB_ENV
        echo "ENABLE_CODE_SIGNING=true" >> $GITHUB_ENV
        
        # Clean up certificate file
        rm ~/certs/developer_id_application.p12

    - name: Build app
      run: |
        # Determine code signing settings
        if [ "${{ env.ENABLE_CODE_SIGNING }}" == "true" ]; then
          echo "ðŸ” Building with code signing enabled"
          CODE_SIGN_IDENTITY="${{ env.CODE_SIGN_IDENTITY }}"
          CODE_SIGNING_REQUIRED=YES
          CODE_SIGNING_ALLOWED=YES
          # Enable hardened runtime for notarization
          OTHER_CODE_SIGN_FLAGS="--options=runtime"
          echo "Code signing identity: $CODE_SIGN_IDENTITY"
        else
          echo "âš ï¸  Building without code signing (app will trigger Gatekeeper warnings)"
          CODE_SIGN_IDENTITY=""
          CODE_SIGNING_REQUIRED=NO
          CODE_SIGNING_ALLOWED=NO
          OTHER_CODE_SIGN_FLAGS=""
          echo "To enable code signing, configure the required secrets. See docs/code-signing.md"
        fi
        
        # Build the main app first
        xcodebuild -project ScreenshotOrganizer.xcodeproj \
                   -scheme ScreenshotOrganizer \
                   -configuration Release \
                   -derivedDataPath build \
                   CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY" \
                   CODE_SIGNING_REQUIRED=$CODE_SIGNING_REQUIRED \
                   CODE_SIGNING_ALLOWED=$CODE_SIGNING_ALLOWED \
                   OTHER_CODE_SIGN_FLAGS="$OTHER_CODE_SIGN_FLAGS" \
                   build
        
        # Build the launcher app
        xcodebuild -project ScreenshotOrganizer.xcodeproj \
                   -scheme ScreenshotOrganizerLauncher \
                   -configuration Release \
                   -derivedDataPath build \
                   CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY" \
                   CODE_SIGNING_REQUIRED=$CODE_SIGNING_REQUIRED \
                   CODE_SIGNING_ALLOWED=$CODE_SIGNING_ALLOWED \
                   OTHER_CODE_SIGN_FLAGS="$OTHER_CODE_SIGN_FLAGS" \
                   build
    
    - name: Notarize app
      if: ${{ env.ENABLE_CODE_SIGNING == 'true' }}
      run: |
        # Create app archive for notarization
        APP_PATH="build/Build/Products/Release/ScreenshotOrganizer.app"
        
        # Verify the app is properly signed
        echo "ðŸ” Verifying code signature..."
        codesign --verify --verbose=2 "$APP_PATH"
        spctl --assess --verbose=2 --type exec "$APP_PATH"
        
        # Create zip for notarization
        echo "ðŸ“¦ Creating archive for notarization..."
        ditto -c -k --keepParent "$APP_PATH" "ScreenshotOrganizer-notarization.zip"
        
        # Submit for notarization
        echo "ðŸš€ Submitting for notarization..."
        xcrun notarytool submit "ScreenshotOrganizer-notarization.zip" \
                       --apple-id "${{ secrets.APPLE_ID }}" \
                       --password "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" \
                       --team-id "${{ secrets.APPLE_TEAM_ID }}" \
                       --wait \
                       --timeout 10m
        
        # Staple the notarization to the app
        echo "ðŸ“Ž Stapling notarization..."
        xcrun stapler staple "$APP_PATH"
        
        # Verify notarization
        echo "âœ… Verifying notarization..."
        xcrun stapler validate "$APP_PATH"
        spctl --assess --verbose=2 --type exec "$APP_PATH"
        
        echo "ðŸŽ‰ App successfully signed and notarized!"
        
        # Clean up notarization archive
        rm "ScreenshotOrganizer-notarization.zip"

    - name: Cleanup keychain
      if: ${{ env.ENABLE_CODE_SIGNING == 'true' }}
      run: |
        # Clean up temporary keychain
        if [ -n "${{ env.KEYCHAIN_PATH }}" ]; then
          security delete-keychain "${{ env.KEYCHAIN_PATH }}" || true
        fi

    - name: Package app
      run: |
        # List what was built for debugging
        echo "Built products:"
        ls -la build/Build/Products/Release/
        
        # Create release directory
        mkdir -p release
        
        # Copy the main app (which should contain the launcher)
        cp -R build/Build/Products/Release/ScreenshotOrganizer.app release/
        
        # Verify the app structure
        echo "App structure:"
        find release/ScreenshotOrganizer.app -type d -name "*Launcher*" || echo "No launcher directory found"
        
        # Determine the artifact name based on whether this is a tag or not
        if [[ "${{ github.ref_type }}" == "tag" ]]; then
          ARTIFACT_NAME="ScreenshotOrganizer-${{ github.ref_name }}"
          echo "Tagged release artifact will be: $ARTIFACT_NAME"
        else
          ARTIFACT_NAME="ScreenshotOrganizer-${{ github.sha }}"
          echo "Development artifact will be: $ARTIFACT_NAME"
        fi
        
        # Create dir with the determined name
        mkdir "$ARTIFACT_NAME"
        
        # move app to the artifact dir
        mv "release/ScreenshotOrganizer.app" "$ARTIFACT_NAME"
        
        # Show final dir info
        ls -ld "$ARTIFACT_NAME"
        
        # Store the artifact name for later steps
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ github.ref_type == 'tag' && format('ScreenshotOrganizer-{0}', github.ref_name) || format('ScreenshotOrganizer-{0}', github.sha) }}
        path: ${{ env.ARTIFACT_NAME }}
        retention-days: 30
    
    - name: Upload release asset (on tag)
      if: startsWith(github.ref, 'refs/tags/v')
      run: |
        # Create zip file for release asset
        zip -r "$ARTIFACT_NAME.zip" "$ARTIFACT_NAME"
    
    - name: Create GitHub release (on tag)
      if: startsWith(github.ref, 'refs/tags/v')
      uses: softprops/action-gh-release@v1
      with:
        files: ${{ env.ARTIFACT_NAME }}.zip
        name: Release ${{ github.ref_name }}
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
